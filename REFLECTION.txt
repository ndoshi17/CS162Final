When I started writing this program I realized that the majority of the logic and would have to be in the maze class. Everything else would just be a class that could be interacted with. So as I started I wrote all of the files for the maze locations and the poeple in the maze, then went through all of those and tested their functionality in my main file. Such as testing whether a wall is occupiable or not and whether an open space had an explorer or whether it had a TA or an instructor. This essentially tested the functionality of all of my fundamental classes that would then me used in my classes such a maze level and maze. After I created the maze location files and began testing reading in the first level into my maze level class. I would print out the maze to see if my print function was also working. I eventually got the reading in to work as intended. Once I had this I was able to move on to the functionality of the mazelevel, being able to move the character, an making sure the old location would not display the character in it. I would start the character at the beginning of the level and to test my move function I moved the character in every direction, then to error check I tried to move the character outside of the maze or into a wall and tested every direction. Once I knew my character could move around one level and would know when it was on the ladder, I began to create my maze class. This took minimal reworking for reading in because all I had to do was read in two extra levels and that would create the whole maze. I then only had the student running around the maze and checked the completely functionality of the student's movement including up and down the ladder. Afterwards since I already had the TA and instructor class I simply added them to the maze class and then for the tas created a function that would randomly add them to the current level of the maze. Once I had the tas wandering the maze I tested to see whether my student could recognize when it was adjacent to a tas. After I thought about creating a reset level function. At first I thought the function would involve deleting the TAs and creating new ones but I realized that that would be a lot more work than just setting the TAs location to a new random location and then changing whether there was a TA at their old location and at their new location. The same logic applied for the student except the student would move to the beginning of the level. Finally I added the reset level to the times when the student was adjacent to a TA. My TAs already had their appease logic in place and had been tested from before so all I had to do was create skill in the maze that the student could pick up. I did this simply by setting the location to have a skill and then since the get_char of the location already knew how to handle this the display process didn't need any chances. I then went on to being able to check whether the student was next to the instructor and finally had to create a reset maze function. This brought up some issues because every time I went up a level the level I was originally on did not clear its TA's and skills this made it so that if I reset the maze the and came back to level there would be too many locations that had TAs and skills. So then I made it so that the locations with the TA's and skills booleans for those object to be false and then move up to the next level. This made is so that the reset maze only had to clear the current level then sets the level to the first level and sets the explorers position to the starting point and finally adds the TAs and skills to the level. Finally I had my program fully running and since I had checked my frees for every place I allocated memory early on in the work it had no memory leaks. I realized that the low level error and functionality checking really helped when it came to putting the whole program together. I had very few logic errors and only had memory leaks when I would create a new allocation and forget to put it in the destructor at early stage. The biggest help on this lab was doing the lab and the previous assignment because a lot of the framework for this assignment.